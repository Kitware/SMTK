#=============================================================================
#
#  Copyright (c) Kitware, Inc.
#  All rights reserved.
#  See LICENSE.txt for details.
#
#  This software is distributed WITHOUT ANY WARRANTY; without even
#  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#  PURPOSE.  See the above copyright notice for more information.
#
#=============================================================================

# For Windows builds, we must initialize our python interpreter with
# "Py_NoSiteFlag" enabled. We therefore import it here instead. Since this
# module is usually imported at python's initialization, this should have no
# effect when another python implementation imports smtk.
import site
import sys

__all__ = ('common', 'attribute', 'extension', 'model',
           'mesh', 'io', 'project', 'session', 'simulation', 'task')

appContext = None

def _windows_dll_path():
    import os
    _smtk_python_path = '@SMTK_PYTHON_MODULEDIR@/smtk'
    _smtk_dll_path = '@CMAKE_INSTALL_BINDIR@'
    # Compute the DLL path based on the location of the file and traversing up
    # the installation prefix to append the DLL path.
    _smtk_dll_directory = os.path.dirname(os.path.abspath(__file__))
    # Loop while we have components to remove.
    while _smtk_python_path:
        # Strip a directory away.
        _smtk_python_path = os.path.dirname(_smtk_python_path)
        _smtk_dll_directory = os.path.dirname(_smtk_dll_directory)
    _smtk_dll_directory = os.path.join(_smtk_dll_directory, _smtk_dll_path)
    # We never remove this path; it is required for SMTK to work and there's no
    # scope where we can easily remove the directory again.
    _ = os.add_dll_directory(_smtk_dll_directory)

    # Build tree support.
    try:
        from . import _build_paths

        # Add any paths needed for the build tree.
        for path in _build_paths.paths:
            _ = os.add_dll_directory(path)
    except ImportError:
        # Relocatable install tree (or non-Windows).
        pass


# CPython 3.8 added behaviors which modified the DLL search path on Windows to
# only search "blessed" paths. When importing SMTK, ensure that SMTK's DLLs are
# in this set of "blessed" paths.
if sys.version_info >= (3, 8) and sys.platform == 'win32':
    _windows_dll_path()

def findAvailablePlugins():
    """Search this SMTK installation for plugins, returning their full paths."""
    import os
    import smtk.common
    import smtk.plugin
    pluginList = []
    # Look for plugins relative to the smtk.common python library.
    pluginDir = os.path.join(
        smtk.common.Paths.pathToThisLibrary(),
        'smtk-' + smtk.common.Version.number())
    # Each plugin lives in its own directory and has a name that ends with
    # `Plugin.so` (linux, macos) or `Plugin.dll` (windows).
    ending = 'Plugin.so' if sys.platform != 'win32' else 'Plugin.dll'
    for pluginCheck in [x for x in os.listdir(pluginDir) if os.path.isdir(os.path.join(pluginDir,x))]:
        entries = os.listdir(os.path.join(pluginDir, pluginCheck))
        pluginList += ([os.path.join(pluginDir, pluginCheck, x) for x in entries if x.endswith(ending)])
    return pluginList

def loadPlugins(pluginList = None):
    """Load all of the provided plugins in pluginList or, if empty, load all available plugins.

    This function returns a list of loaded and a list of skipped plugins.
    Example usage:
        import smtk
        loaded, skipped = smtk.loadPlugins()
        print('Loaded %d / %d plugins' % (len(loaded), len(skipped)))
    """
    skipped = []
    loaded = []
    try:
        from paraview.simple import LoadPlugin
        if pluginList == None:
            pluginList = findAvailablePlugins()
        for plugin in pluginList:
            try:
                LoadPlugin(plugin)
                loaded.append(plugin)
            except:
                skipped.append(plugin)
                # Allow loading a plugin to fail without causing all plugin loads to fail.
                pass
    except:
        pass
    if not pluginList or len(skipped) == len(pluginList):
        print('Unable to load any plugins.')
    elif len(skipped) > 0:
        print('Unable to load %d / %d plugins.' % (len(skipped), len(pluginList)))
    return (loaded, skipped)

def applicationContext():
    """Return an instance of smtk.common.Managers.

    Typically, an application or script will create a single instance of smtk.common.Managers
    and use it to hold all of the application's state (at least as far as SMTK is concerned).
    Inside ParaView-based applications, this is created by client-side plugins and simply
    fetched by this method. For scripts run outside the ParaView, this will create an instance
    for you.
    """
    global appContext
    import smtk.common
    import smtk.plugin
    if appContext == None:
        try:
            from smtk.extension.paraview.appcomponents import pqSMTKBehavior
            bb = pqSMTKBehavior.instance()
            if bb:
                bb.updateWrapperMap()
                if bb.haveActiveWrapper():
                    appContext = bb.activeWrapperCommonManagers()
        except:
            pass
        if appContext == None:
            # Create a managers instance, then initialize and return it.
            appContext = smtk.common.Managers.create()
            smtk.plugin.registerPluginsTo(appContext)
    return appContext

def wrappingProtocol():
    return 'pybind11'
