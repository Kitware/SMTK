#=============================================================================
#
#  Copyright (c) Kitware, Inc.
#  All rights reserved.
#  See LICENSE.txt for details.
#
#  This software is distributed WITHOUT ANY WARRANTY; without even
#  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#  PURPOSE.  See the above copyright notice for more information.
#
#=============================================================================

""" add_obstacle.py:

This operator accepts as input an OpenFOAM wind tunnel and either a Wavefront
(.obj) or a stereolithography (.stl) auxiliary geometry representing a
triangulated surface geometry. It uses OpenFOAM's snappyHexMesh to combine the
wind tunnel background mesh and the surface geometry.

"""

import glob
import os
import platform
import shutil
import smtk
import smtk.io
import smtk.io.vtk
import smtk.mesh
import smtk.model
import smtk.bridge.openfoam
import subprocess

import constant_input_files


@smtk.model.operator("add obstacle", smtk.bridge.openfoam.Session)
class add_obstacle(smtk.model.Operator):

    def __init__(self):
        smtk.model.Operator.__init__(self)

    def name(self):
        return "add obstacle"

    def className(self):
        return self.__name__

    def operateInternal(self):

        # Access the wind tunnel
        windTunnel = smtk.model.Model(
            self.specification().find('wind tunnel').value(0))

        # Access the obstacle
        obstacle = smtk.model.AuxiliaryGeometry(
            self.specification().find('obstacle').value(0))
        path, filename = os.path.split(obstacle.url())
        filenameBase, ext = os.path.splitext(filename)

        # Access the bounding box values
        bbox = []
        for dim in ['x dimensions', 'y dimensions', 'z dimensions']:
            bbox.append(self.specification().find(dim).value(0))
            bbox.append(self.specification().find(dim).value(1))

        if self.activeSession().workingDirectoryExists() == False:
            self.activeSession().createWorkingDirectory()

        triSurfaceDirectory = self.activeSession(
        ).workingDirectory() + '/constant/triSurface'
        if not os.path.exists(triSurfaceDirectory):
            os.makedirs(triSurfaceDirectory)
        shutil.copy(obstacle.url(), triSurfaceDirectory)

        systemDirectory = self.activeSession().workingDirectory() + '/system'
        if not os.path.exists(systemDirectory):
            os.makedirs(systemDirectory)

        constant_input_files.write_surface_feature_extract_dict(
            systemDirectory, filename)
        constant_input_files.write_fv_schemes_dict(systemDirectory)
        constant_input_files.write_fv_solution_dict(systemDirectory)
        constant_input_files.write_mesh_quality_dict(systemDirectory)

        with open(systemDirectory + '/snappyHexMeshDict', 'w') as f:
            f.write(
                "/*--------------------------------*- C++ -*----------------------------------*\\\n"
                "| =========                 |                                                 |\n"
                "| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n"
                "|  \\\\    /   O peration     | Version:  plus                                  |\n"
                "|   \\\\  /    A nd           | Web:      www.OpenFOAM.com                      |\n"
                "|    \\\\/     M anipulation  |                                                 |\n"
                "\*---------------------------------------------------------------------------*/\n"
                "\n"
                "/* Generated by SMTK (http://www.computationalmodelbuilder.org/smtk/) */\n"
                "\n"
                "FoamFile\n"
                "{\n"
                "    version     2.0;\n"
                "    format      ascii;\n"
                "    class       dictionary;\n"
                "    object      snappyHexMeshDict;\n"
                "}\n"
                "\n"
                "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n"
                "\n"
            )

            f.write('castellatedMesh true;\n')
            f.write('snap true;\n')
            f.write('addLayers true;\n\n')
            f.write('geometry\n{\n')
            f.write('    %s\n    {\n' % (filenameBase))
            f.write(' ' * 8 + 'type triSurfaceMesh;\n')
            f.write(' ' * 8 + 'file "%s";\n' % (filename))
            f.write('    }\n\n')
            f.write('    refinementBox\n    {\n')
            f.write(' ' * 8 + 'type searchableBox;\n')
            f.write(' ' * 8 + 'min (%f %f %f);\n' %
                    (bbox[0], bbox[2], bbox[4]))
            f.write(' ' * 8 + 'max (%f %f %f);\n' %
                    (bbox[1], bbox[3], bbox[5]))
            f.write('    }\n};\n\n')

            # TODO: controls for these values
            f.write('castellatedMeshControls\n')
            f.write('{\n')
            f.write('    maxLocalCells 100000;\n')
            f.write('    maxGlobalCells 2000000;\n')
            f.write('    minRefinementCells 10;\n')
            f.write('    maxLoadUnbalance 0.10;\n')
            f.write('    nCellsBetweenLevels 3;\n')
            f.write('    features\n')
            f.write('    (\n')
            f.write('        {\n')
            f.write('            file "%s.eMesh";\n' % (filenameBase))
            f.write('            level 6;\n')
            f.write('        }\n')
            f.write('    );\n')
            f.write('    refinementSurfaces\n')
            f.write('    {\n')
            f.write('        %s\n' % filenameBase)
            f.write('        {\n')
            f.write('            level (5 6);\n')
            f.write('            patchInfo\n')
            f.write('            {\n')
            f.write('                type wall;\n')
            f.write('                inGroups (%s);\n' % (filenameBase))
            f.write('            }\n')
            f.write('        }\n')
            f.write('    }\n')
            f.write('    resolveFeatureAngle 30;\n')
            f.write('    refinementRegions\n')
            f.write('    {\n')
            f.write('        refinementBox\n')
            f.write('        {\n')
            f.write('            mode inside;\n')
            f.write('            levels ((1E15 4));\n')
            f.write('        }\n')
            f.write('    }\n')
            f.write('    locationInMesh (3.0001 3.0001 0.43);\n')
            f.write('    allowFreeStandingZoneFaces true;\n')
            f.write('}\n')
            f.write('snapControls\n')
            f.write('{\n')
            f.write('    nSmoothPatch 3;\n')
            f.write('    tolerance 2.0;\n')
            f.write('    nSolveIter 30;\n')
            f.write('    nRelaxIter 5;\n')
            f.write('        nFeatureSnapIter 10;\n')
            f.write('        implicitFeatureSnap false;\n')
            f.write('        explicitFeatureSnap true;\n')
            f.write('        multiRegionFeatureSnap false;\n')
            f.write('}\n')
            f.write('addLayersControls\n')
            f.write('{\n')
            f.write('    relativeSizes true;\n')
            f.write('    layers\n')
            f.write('    {\n')
            f.write('        \"%s.*\"\n' % (filenameBase))
            f.write('        {\n')
            f.write('            nSurfaceLayers 1;\n')
            f.write('        }\n')
            f.write('    }\n')
            f.write('    expansionRatio 1.0;\n')
            f.write('    finalLayerThickness 0.3;\n')
            f.write('    minThickness 0.1;\n')
            f.write('    nGrow 0;\n')
            f.write('    featureAngle 60;\n')
            f.write('    slipFeatureAngle 30;\n')
            f.write('    nRelaxIter 3;\n')
            f.write('    nSmoothSurfaceNormals 1;\n')
            f.write('    nSmoothNormals 3;\n')
            f.write('    nSmoothThickness 10;\n')
            f.write('    maxFaceThicknessRatio 0.5;\n')
            f.write('    maxThicknessToMedialRatio 0.3;\n')
            f.write('    minMedianAxisAngle 90;\n')
            f.write('    nBufferCellsNoExtrude 0;\n')
            f.write('    nLayerIter 50;\n')
            f.write('}\n')
            f.write('meshQualityControls\n')
            f.write('{\n')
            f.write('    #include \"meshQualityDict\"\n')
            f.write('    nSmoothScale 4;\n')
            f.write('    errorReduction 0.75;\n')
            f.write('}\n')
            f.write('writeFlags\n')
            f.write('(\n')
            f.write('    scalarLevels\n')
            f.write('    layerSets\n')
            f.write('    layerFields\n')
            f.write(');\n')
            f.write('mergeTolerance 1e-6;\n')
            f.write('\n')
            f.write('\n')
            f.write(
                '// ************************************************************************* //\n')

        if platform.system() == 'Linux':
            # create the mesh
            executableArgs = ['surfaceFeatureExtract', '-case',
                              self.activeSession().workingDirectory()]
            subprocess.call(executableArgs)

            # run snappyHexMesh
            executableArgs = [
                'snappyHexMesh', '-case', self.activeSession(
                ).workingDirectory(),
                              '-overwrite']
            subprocess.call(executableArgs)

            # extract the mesh surface
            executableArgs = [
                'foamToSurface', '-case', self.activeSession(
                ).workingDirectory(),
                              self.activeSession().workingDirectory() + '/snappyHexMeshSurface.stl']
            subprocess.call(executableArgs)
        elif platform.system() == 'Darwin':

            # Run from the working directory
            os.chdir(self.activeSession().workingDirectory())

            # create the mesh
            executableArgs = ['/bin/bash',
                              self.activeSession().workingDirectory(
                              ) + '/run_openfoam.sh',
                              'surfaceFeatureExtract']
            subprocess.call(executableArgs)

            # run snappyHexMesh
            executableArgs = ['/bin/bash',
                              self.activeSession().workingDirectory(
                              ) + '/run_openfoam.sh',
                              'snappyHexMesh', '-overwrite']
            subprocess.call(executableArgs)

            # extract the mesh surface
            executableArgs = ['/bin/bash',
                              self.activeSession().workingDirectory(
                              ) + '/run_openfoam.sh',
                              'foamToSurface', 'snappyHexMeshSurface.stl']
            subprocess.call(executableArgs)

        # several mesh files are created (I think it's one for each checkpoint
        # of the mesher). Use the last one.
        surfaceFiles = glob.glob(self.activeSession().workingDirectory() +
                                 '/snappyHexMeshSurface*.stl')
        surfaceFiles.sort()

        # read in the surface mesh
        imprt = smtk.io.vtk.ImportSTLFile()
        collection = imprt(
            surfaceFiles[-1], self.activeSession().meshManager())

        if (not collection) or (collection.isValid() is False):
            smtk.ErrorMessage(self.log(), "Could not read surface mesh.")
            return self.createResult(smtk.model.OPERATION_FAILED)

        obstacle_cells = collection.cells()
        meshes = []
        for i in xrange(6):
            meshes.append(collection.meshes(smtk.mesh.Domain(i)))
        for mesh in meshes:
            obstacle_cells = smtk.mesh.set_difference(
                obstacle_cells, mesh.cells())
        meshes.append(collection.createMesh(obstacle_cells))

        wall_labels = windTunnel.stringProperty('wall labels')
        wall_labels.append(filenameBase)

        for mesh, label in zip(meshes, wall_labels):
            smtk.InfoMessage(self.log(), 'Surface \'%s\' has %d cells and %d points' %
                             (label, mesh.cells().size(), mesh.points().size()))

        # Our collections will already have a UUID, so here we create a model
        # given the model manager and uuid
        model = self.manager().insertModel(collection.entity())

        model.setSession(smtk.model.SessionRef(
            self.manager(), self.activeSession().sessionId()))

        collection.associateToModel(model.entity())

        # Describe a volume that comprises the entire wind tunnel
        volume = self.manager().addVolume()
        model.addCell(volume)
        model.findOrAddRawRelation(volume)
        volume.findOrAddRawRelation(model)

        # Describe the faces of the wind tunnel
        faces = []
        for i, name in zip(range(len(wall_labels)), wall_labels):
            face = self.manager().addFace()
            model.addCell(face)
            volume.findOrAddRawRelation(face)
            face.findOrAddRawRelation(volume)
            face.setName(name)
            meshes[i].setModelEntity(face)
            faces.append(face)

        result = self.createResult(smtk.model.OPERATION_SUCCEEDED)

        resultModels = result.findModelEntity("model")
        resultModels.setValue(model)

        created = result.findModelEntity("created")
        created.setNumberOfValues(6)
        created.setValue(0, model)
        created.setValue(1, volume)
        for i in xrange(4):
            created.setValue(i + 2, faces[i])
        created.setIsEnabled(True)

        # Return with success
        return result
