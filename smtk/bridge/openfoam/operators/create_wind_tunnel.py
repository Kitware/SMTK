#=============================================================================
#
#  Copyright (c) Kitware, Inc.
#  All rights reserved.
#  See LICENSE.txt for details.
#
#  This software is distributed WITHOUT ANY WARRANTY; without even
#  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#  PURPOSE.  See the above copyright notice for more information.
#
#=============================================================================

""" create_wind_tunnel.py:

This operator accepts as input the parameters for an axis-aligned background
mesh. It uses OpenFOAM's blockMesh to construct a wind tunnel background mesh.

"""

import os
import platform
import smtk
import smtk.io
import smtk.io.vtk
import smtk.mesh
import smtk.model
import smtk.bridge.openfoam
import subprocess


@smtk.model.operator("create wind tunnel", smtk.bridge.openfoam.Session)
class create_wind_tunnel(smtk.model.Operator):

    def __init__(self):
        smtk.model.Operator.__init__(self)

    def name(self):
        return "create wind tunnel"

    def className(self):
        return self.__name__

    def operateInternal(self):

        # Access the bounding box values
        dimensions = []
        for dim in ['x dimensions', 'y dimensions', 'z dimensions']:
            dimensions.append(self.specification().find(dim).value(0))
            dimensions.append(self.specification().find(dim).value(1))

        # Access the scaling factors
        scaling_factor = self.specification().find('scaling factor').value(0)

        # Access the number of cells
        number_of_cells = [self.specification().find(
            'number of cells').value(i) for i in xrange(3)]

        # Access the expansion ratio
        expansion_ratio = [self.specification().find(
            'expansion ratio').value(i) for i in xrange(3)]

        # Access the wind direction
        wind_direction = self.specification().find('wind direction').value(0)

        wall_xmin = [0, 4, 7, 3]
        wall_xmax = [1, 2, 6, 5]
        wall_ymin = [0, 1, 5, 4]
        wall_ymax = [3, 7, 6, 2]
        wall_zmin = [0, 3, 2, 1]
        wall_zmax = [4, 5, 6, 7]

        inlet = []
        outlet = []
        front = []
        back = []
        floor = []
        ceiling = []
        if wind_direction == 'from -x to +x':
            inlet = wall_xmin
            outlet = wall_xmax
            front = wall_ymin
            back = wall_ymax
            floor = wall_zmin
            ceiling = wall_zmax
        elif wind_direction == 'from +x to -x':
            inlet = wall_xmax
            outlet = wall_xmin
            front = wall_ymax
            back = wall_ymin
            floor = wall_zmin
            ceiling = wall_zmax
        elif wind_direction == 'from -y to +y':
            inlet = wall_ymin
            outlet = wall_ymax
            front = wall_xmin
            back = wall_xmax
            floor = wall_zmin
            ceiling = wall_zmax
        elif wind_direction == 'from +y to -y':
            inlet = wall_ymax
            outlet = wall_ymin
            front = wall_xmax
            back = wall_xmin
            floor = wall_zmin
            ceiling = wall_zmax

        wall_labels = ['inlet', 'outlet', 'front', 'back', 'floor', 'ceiling']
        wall_types = ['patch', 'patch', 'patch', 'patch', 'wall', 'patch']
        wall_indices = [inlet, outlet, front, back, floor, ceiling]

        if self.activeSession().workingDirectoryExists() == False:
            self.activeSession().createWorkingDirectory()

        systemDirectory = self.activeSession().workingDirectory() + '/system'
        if not os.path.exists(systemDirectory):
            os.makedirs(systemDirectory)

        with open(systemDirectory + '/blockMeshDict', 'w') as f:
            f.write(
                "/*--------------------------------*- C++ -*----------------------------------*\\\n"
                "| =========                 |                                                 |\n"
                "| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n"
                "|  \\\\    /   O peration     | Version:  plus                                  |\n"
                "|   \\\\  /    A nd           | Web:      www.OpenFOAM.com                      |\n"
                "|    \\\\/     M anipulation  |                                                 |\n"
                "\*---------------------------------------------------------------------------*/\n"
                "\n"
                "/* Generated by SMTK (http://www.computationalmodelbuilder.org/smtk/) */\n"
                "\n"
                "FoamFile\n"
                "{\n"
                "    version     2.0;\n"
                "    format      ascii;\n"
                "    class       dictionary;\n"
                "    object      blockMeshDict;\n"
                "}\n"
                "\n"
                "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n"
                "\n"
            )

            f.write('scale   %d;\n\n' % scaling_factor)
            f.write('vertices\n(\n')
            f.write('    (%d %d %d)\n' %
                    (dimensions[0], dimensions[2], dimensions[4]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[1], dimensions[2], dimensions[4]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[1], dimensions[3], dimensions[4]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[0], dimensions[3], dimensions[4]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[0], dimensions[2], dimensions[5]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[1], dimensions[2], dimensions[5]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[1], dimensions[3], dimensions[5]))
            f.write('    (%d %d %d)\n' %
                    (dimensions[0], dimensions[3], dimensions[5]))
            f.write(');\n\n')
            f.write(
                'blocks\n(\n    hex (%d %d %d %d %d %d %d %d) ' % tuple(range(8)))
            f.write('(%d %d %d) ' % tuple(number_of_cells))
            f.write('simpleGrading (%d %d %d)\n);\n\n' %
                    tuple(expansion_ratio))
            f.write('edges\n(\n);\n\n')
            f.write('boundary\n(\n')
            for wall_label, wall_type, wall_index in zip(wall_labels, wall_types, wall_indices):
                f.write(' ' * 4 + '%s\n' % (wall_label))
                f.write(' ' * 4 + '{\n')
                f.write(' ' * 8 + 'type %s;\n' % (wall_type))
                f.write(' ' * 8 + 'faces\n' + ' ' * 8 + '(\n')
                f.write(' ' * 12 + '(%d %d %d %d)\n' % tuple(wall_index))
                f.write(' ' * 8 + ');\n')
                f.write(' ' * 4 + '}\n')
            f.write(');\n\n')
            f.write(
                '// ************************************************************************* //\n')

        if platform.system() == 'Linux':
            # create the mesh
            executableArgs = [
                'blockMesh', '-case', self.activeSession().workingDirectory()]
            subprocess.call(executableArgs)

            # extract the mesh surface
            executableArgs = [
                'foamToSurface', '-case', self.activeSession(
                ).workingDirectory(),
                              self.activeSession().workingDirectory() + '/blockMeshSurface.stl']
            subprocess.call(executableArgs)
        elif platform.system() == 'Darwin':

            # Run from the working directory
            os.chdir(self.activeSession().workingDirectory())

            # create the mesh
            print 'running \'', self.activeSession().workingDirectory() + '/run_openfoam.sh', \
                'blockMesh\''
            executableArgs = ['/bin/bash',
                              self.activeSession().workingDirectory(
                              ) + '/run_openfoam.sh',
                              'blockMesh']
            subprocess.call(executableArgs)

            # extract the mesh surface
            executableArgs = ['/bin/bash',
                              self.activeSession().workingDirectory(
                              ) + '/run_openfoam.sh',
                              'foamToSurface', 'blockMeshSurface.stl']
            subprocess.call(executableArgs)

        # read in the surface mesh
        imprt = smtk.io.vtk.ImportSTLFile()
        collection = imprt(
            self.activeSession().workingDirectory() + '/blockMeshSurface.stl',
                           self.activeSession().meshManager())

        if collection.isValid() is False:
            smtk.ErrorMessage(self.log(), "Could not read surface mesh.")
            return self.createResult(smtk.model.OPERATION_FAILED)

        # Access our partitioned surface mesh
        meshes = []
        for i in xrange(6):
            meshes.append(collection.meshes(smtk.mesh.Domain(i)))

        for mesh, label in zip(meshes, wall_labels):
            smtk.InfoMessage(self.log(), 'Surface \'%s\' has %d cells and %d points' %
                             (label, mesh.cells().size(), mesh.points().size()))

        # Our collections will already have a UUID, so here we create a model
        # given the model manager and uuid
        model = self.manager().insertModel(collection.entity())

        model.setSession(smtk.model.SessionRef(
            self.manager(), self.activeSession().sessionId()))
        model.setStringProperty('wall labels', wall_labels)

        collection.associateToModel(model.entity())

        # Describe a volume that comprises the entire wind tunnel
        volume = self.manager().addVolume()
        model.addCell(volume)
        model.findOrAddRawRelation(volume)
        volume.findOrAddRawRelation(model)

        # Describe the faces of the wind tunnel
        faces = []
        for i, name in zip(range(len(wall_labels)), wall_labels):
            face = self.manager().addFace()
            model.addCell(face)
            volume.findOrAddRawRelation(face)
            face.findOrAddRawRelation(volume)
            face.setName(name)
            meshes[i].setModelEntity(face)
            faces.append(face)

        result = self.createResult(smtk.model.OPERATION_SUCCEEDED)

        resultModels = result.findModelEntity("model")
        resultModels.setValue(model)

        created = result.findModelEntity("created")
        created.setNumberOfValues(len(wall_labels))
        created.setValue(0, model)
        created.setValue(1, volume)
        for i in xrange(len(wall_labels)):
            created.setValue(i + 2, faces[i])
        created.setIsEnabled(True)

        # Return with success
        return result
